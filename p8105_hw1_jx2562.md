p8105_hw1_jx2562
================
Jingyi
2023-09-15

``` r
library(tidyverse)
library(moderndive)
library(ggplot2)
```

# Problem 1

Here we use ggplot to scatter the correlation between *temp* and
*time_hour*, with *humid* indicating the color of the points.

Load the libraries (**moderndive** and **ggplot**) and dataset
(**early_january_weather**) we are going to use.

``` r
data("early_january_weather")
```

The dataset **early_january_weather** include 15 columns and 358 rows.

The variables in the dataset includes *origin, year, month, day, hour,
temp, dewp, humid, wind_dir, wind_speed, wind_gust, precip, pressure,
visib, time_hour*.

The mean of the temperature in the early january is 39.5821229.

``` r
ggplot(data = early_january_weather, aes(x = time_hour, y = temp, color = humid)) +
  geom_point()
```

![](p8105_hw1_jx2562_files/figure-gfm/plot-1.png)<!-- -->

``` r
ggsave("temp over time.jpg")
```

    ## Saving 7 x 5 in image

It is apparent from the graph that as time pass by, the temperature grew
gradually with fluctuation. In terms of humidity, it rose up and reached
its summit in January 14.

# Problem 2

Here we created a dataframe including *numeric*, *boolean*, *character*,
and *factor* variables. Then, some operations were conducted on the
dataframe to help us better comprehend these concepts in R.

First, we created a dataframe containing: \* a random sample of size 10
from a standard Normal distribution \* a logical vector indicating
whether elements of the sample are greater than 0 \* a character vector
of length 10 \* a factor vector of length 10, with 3 different factor
“levels”

``` r
df = tibble(
  std_norm = rnorm(10),
  logical_vec = std_norm > 0,
  char_vec = c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J"),
  factor_vec = factor(sample(c("Low", "Medium", "High"), size = 10, replace = TRUE))
)
df
```

    ## # A tibble: 10 × 4
    ##    std_norm logical_vec char_vec factor_vec
    ##       <dbl> <lgl>       <chr>    <fct>     
    ##  1  -0.0686 FALSE       A        High      
    ##  2   0.394  TRUE        B        High      
    ##  3   0.506  TRUE        C        High      
    ##  4  -1.18   FALSE       D        High      
    ##  5   0.646  TRUE        E        High      
    ##  6  -0.0466 FALSE       F        Low       
    ##  7   1.20   TRUE        G        Low       
    ##  8  -0.581  FALSE       H        Medium    
    ##  9  -0.207  FALSE       I        Medium    
    ## 10  -0.473  FALSE       J        High

This below code chunk took the mean of each column and saw how it goes.

``` r
mean_std_norm <- mean(df %>% pull(std_norm))
mean_logical <- mean(df %>% pull(logical_vec))
mean_char <- mean(df %>% pull(char_vec))
```

    ## Warning in mean.default(df %>% pull(char_vec)): argument is not numeric or
    ## logical: returning NA

``` r
mean_factor <- mean(df %>% pull(factor_vec))
```

    ## Warning in mean.default(df %>% pull(factor_vec)): argument is not numeric or
    ## logical: returning NA

``` r
mean_std_norm
```

    ## [1] 0.01926808

``` r
mean_logical
```

    ## [1] 0.4

``` r
mean_char
```

    ## [1] NA

``` r
mean_factor
```

    ## [1] NA

We can take the mean of *numeric* and *logical* data, but not
*character* and *factor* variables. Instead, an NA was introduced.

``` r
num_logical <- as.numeric(df %>% pull(logical_vec))
num_char <- as.numeric(df %>% pull(char_vec))
```

    ## Warning: NAs introduced by coercion

``` r
num_factor <- as.numeric(df %>% pull(factor_vec))
```

Except for character variable, the other two data types can be converted
to *numeric* data. The result coincided with taking the mean except for
the *factor* variable. Factor variables were discrete labels but not
numbers, so we cannot take their means. The function `mean()` will not
convert the *factor* variables and *character* variable to *numeric*
data first. If we want to calculate the mean of factor variable, we can
convert it to *numeric* data with `as.numeric()`.
